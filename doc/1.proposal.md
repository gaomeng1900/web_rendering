
## 前提

- 用户对框架的依赖
- 换框架的复杂性


- 不同框架顶层概念的相近设计
- 底层接口的分化与互斥


- 一个运行时通用描述层的可行性（前端-IR-后端）



#### 该设计的优势：

- SAO与模块化的设计本身，将是易于维护易于性能优化的
- 能够大大降低顶层框架的开发成本
- 解决底层接口分裂的问题
- IR易于调试与优化
- 透明的降级策略
- 如果成为标准，有可能消除掉平台之间桌面端以及桌面端、Web端开发的区别

---

## 设计

```
场景构建描述（shader、数据、流水线）（THREE，Unity）
↓ 前端
IR 可渲染数据与流水线通用描述（复合数据结构与二进制结构）（对于不同特性只能有选择性的提供，毕竟后端不能支持所有特性）
↓ 后端
底层渲染API（WebGL1/2、WebGPU、Vulkan、Metal、D3D12）（可能需要超出JS上下文）（甚至更加低层调用GPU进行渲染）
```

### 特点：
- 本身需要包含数据，需要数据传输（数据变化、更新、流水线描述）
- 绘制过程是复杂的而非简单指令，需要multipass，还需要一些根据底层API设计的非通用指令
- 不是一次性的工作，而是 per-frame 的重复工作
- IR 目的不只是表明一个重复进行的过程（绘制指令往往是重复的），还要表达以供高效处理的 inter-frame 变化（数据操作等不会重复进行，而是尽在需要的时候完成状态变化）
    - **需要让后端知道如何完成这次状态变化**
    - 又或者，IR只表达状态，但是需要有足够的信息让后端能快速辨别出来不需要重复进行的操作
    - 可以用`RIR(Runtime/Realtime Intermediate Representation)`
- IR 不可能做到完全通用，不同的底层API可能提供无法兼容的设计，不可能全部对上层透明
- 很可能需要保留对上层实例的引用，至少数据只能有一份而不应该每层复制
- 流水线的优化与设计主要

### 预估：
- IR的定位比较麻烦，重新设计一个Metal/Vulkan级别的API是没有意义而且注定失败的
- IR的设计将会是整个项目的核心
- 前端最合理的实现方式是内部改造现有3D库
- 后端需要解析、优化IR表述的过程，处理其中可能存在的兼容性问题，然后调用底层API完成状态的变化
- 最大的风险是底层接口的复杂性和差异

### 现有实践
WebGPU，SPIR

---

## 计划

考虑到我们的开发经验，我们所设计出来的IR肯定是接近THREEJS高级接口和OpenGL低级接口的；
但是为了能使IR更加通用，我们需要学习D3D可Vulkan系列的接口风格，以及Unity等更加通用的顶层引擎所使用的概念。
先从OpenGL开始设计一个初级版本。然后支持multipass流水线。然后加入Unity和Metal的设计。

## Version 0.1

摸索该设计中IR和后端可能面对的问题

- IR
    - `JS复合对象`
    - 概念向OpenGL和THREE靠拢
    - 单流水线
    - 无TransformFeedback
    - glsl only
    - 基本的interframe加速

- Backend
  - `WebGL2`
  - 对IR的基本渲染
  - 基本性能优化
- Frontend
  - 无前端

## Version 0.2

确定该方案的可行性

- IR
  - 可编程流水线
- Backend
  - 可编程流水线
- Frontend
  - `THREE.js`

## Version 0.3

实现该方案的后端优势，稳定IR设计

- IR
  - 加入Vulkan/Metal/D3D的设计理念
  - 支持更复杂的数据链路和流水线
  - 支持可选扩展功能
- Backend
  - `WebGPU` (maybe？如果浏览器端支持较好的话)
  - `WebGL1` (maybe? 将有利于提升影响力，同时也用于设计和检测对扩展功能的降级能力)
  - 支持更抽象的IR渲染
  - 对扩展功能的处理

## Version 0.4

实现前端优势（必须等IR设计趋于稳定才可以扩展前端领域）

- Frontend
  - `Pixi.js` （maybe?）
    - 该项目没有主动部署WebGL2的计划
    - 项目结构比较简单，比THREE清晰
    - 用户群大
    - 可用于检测该结构是否真正具有通用性并带来性能优化

## Version 0.5

探索桌面端更多的可能性

- IR
  - ？JS上下文与其他上下文数据交换
- Backend
  - ？Vulkan直接调用
- Frontend
  - ？桌面端框架