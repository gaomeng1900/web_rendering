
## 前提

- 用户对框架的依赖
- 换框架的复杂性


- 不同框架顶层概念的相近设计
- 底层接口的分化与互斥


- 一个运行时通用描述层的可行性（前端-IR-后端）

---

## 设计

```
场景构建描述（shader、数据、流水线）（THREE，Unity）
↓ 前端
IR 可渲染数据与流水线通用描述（复合数据结构与二进制结构）（对于不同特性只能有选择性的提供，毕竟后端不能支持所有特性）
↓ 后端
底层渲染API（WebGL1/2、WebGPU、Vulkan、Metal、D3D12）（可能需要超出JS上下文）（甚至更加低层调用GPU进行渲染）
```

与LLVM的不同：
- 本身需要包含数据，需要数据传输（数据变化、更新、流水线描述）
- 绘制过程是复杂的而非简单指令，需要multipass，还需要一些根据底层API设计的非通用指令
- 不是一次性的工作，而是 per-frame 的重复工作
- IR 目的不只是表明一个重复进行的过程（绘制指令往往是重复的），还要表达以供高效处理的 inter-frame 变化（数据操作等不会重复进行，而是尽在需要的时候完成状态变化）
    - **需要让后端知道如何完成这次状态变化**
    - 又或者，IR只表达状态，但是需要有足够的信息让后端能快速辨别出来不需要重复进行的操作
- IR 不可能做到完全通用，不同的底层API可能提供无法兼容的设计，不可能全部对上层透明
- 很可能需要保留对上层实例的引用，至少数据只能有一份而不应该每层复制

---

- IR的设计将会是整个项目的核心
- 前端最合理的实现方式是内部改造现有3D库
- 后端需要解析、优化IR表述的过程，处理其中可能存在的兼容性问题，然后调用底层API完成状态的变化

